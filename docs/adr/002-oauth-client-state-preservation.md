# ADR-002: OAuth Client State Preservation for MCP Agentic Clients

## Status
Accepted

## Context

### Problem Statement

When the MCP TypeScript server acts as an OAuth intermediary between agentic clients (Claude Code, MCP Inspector) and OAuth providers (Google, GitHub, Microsoft), there is a critical state parameter mismatch that prevents successful authentication.

**OAuth 2.0/2.1 CSRF Protection Requirement:**
- Clients must send a `state` parameter for CSRF protection
- Authorization servers must return the exact same `state` value
- State mismatch causes authentication to fail

**The MCP Server's Dual Role:**
1. **OAuth Client** to providers (Google, GitHub, Microsoft)
2. **OAuth Server** to agentic clients (Claude Code, MCP Inspector)

This dual role creates **two state parameters** in flight:
- **Client State**: The state sent by the agentic client
- **Server State**: The state generated by the MCP server

### Real-World Failure Scenario

**User Request**: "Testing with Claude Code, it redirected me to login in the browser, then I got this error: Authentication Error - Invalid state parameter. Please try again."

**Error Analysis:**
```
1. Claude Code initiates OAuth:
   GET /auth/google?state=9744e5b283e0a3b024f6793f6d5eb197&redirect_uri=http://localhost:50151/callback

2. MCP Server generates its own state:
   state=abc123... (for session management)

3. Google redirects back to MCP Server:
   GET /auth/google/callback?code=4/0AVGzR1...&state=abc123...

4. MCP Server validates successfully (using server state)

5. MCP Server redirects to Claude Code:
   http://localhost:50151/callback?code=4/0AVGzR1...&state=abc123...
   ❌ WRONG STATE!

6. Claude Code validation fails:
   Expected: state=9744e5b283e0a3b024f6793f6d5eb197
   Received: state=abc123...
   Result: "Invalid state parameter"
```

### Requirements

**Functional Requirements:**
1. Preserve client's original state parameter throughout OAuth flow
2. Support both client-managed and server-managed OAuth flows
3. Maintain backward compatibility with direct server usage
4. Work with all OAuth providers (Google, GitHub, Microsoft, generic)

**Security Requirements:**
1. Maintain CSRF protection for both client and server
2. Validate state parameters at each step
3. Never expose internal session state to clients

**Compatibility Requirements:**
1. Support Claude Code's managed OAuth flow
2. Support MCP Inspector's Dynamic Client Registration (RFC 7591)
3. Support custom OAuth clients following RFC 6749/RFC 9449 (OAuth 2.1)

## Decision

### Solution: Dual-State Session Management

Implement **OAuth client state preservation** by storing both the server state and client state in OAuth sessions, then returning the appropriate state value based on the flow type.

### Architecture

```
┌─────────────┐     state=client-abc     ┌─────────────┐     state=server-xyz    ┌─────────────┐
│ Claude Code │ ──────────────────────> │ MCP Server  │ ──────────────────────> │   Google    │
│             │                          │             │                         │   OAuth     │
│             │                          │ Session:    │                         │             │
│             │                          │ - state:    │                         │             │
│             │                          │   server-xyz│                         │             │
│             │                          │ - clientState: │                      │             │
│             │                          │   client-abc│                         │             │
│             │ <─────────────────────── │             │ <────────────────────── │             │
│             │     state=client-abc     │             │     state=server-xyz    │             │
└─────────────┘     ✅ CORRECT!          └─────────────┘                         └─────────────┘
```

### Implementation Changes

#### 1. Data Model Extension

**File**: `src/auth/providers/types.ts`

```typescript
export interface OAuthSession {
  state: string;              // Server-generated state (for session management)
  codeVerifier: string;
  codeChallenge: string;
  redirectUri: string;
  clientRedirectUri?: string; // Client's callback URI
  clientState?: string;       // ✅ NEW: Client's original state for validation
  scopes: string[];
  provider: OAuthProviderType;
  expiresAt: number;
}
```

#### 2. Session Creation

**File**: `src/auth/providers/base-provider.ts`

```typescript
protected createOAuthSession(
  state: string,
  codeVerifier: string,
  codeChallenge: string,
  clientRedirectUri?: string,
  customScopes?: string[],
  clientState?: string  // ✅ NEW: Accept client state
): OAuthSession {
  const providerName = this.getProviderName();

  if (clientState) {
    logger.oauthDebug('Client state parameter', {
      provider: providerName,
      clientStatePrefix: clientState.substring(0, 8)
    });
  }

  return {
    state,
    codeVerifier,
    codeChallenge,
    redirectUri: this.config.redirectUri,
    clientRedirectUri,
    clientState,  // ✅ Store client's original state
    scopes: customScopes || this.config.scopes || this.getDefaultScopes(),
    provider: this.getProviderType(),
    expiresAt: Date.now() + this.SESSION_TIMEOUT,
  };
}
```

#### 3. Client Redirect Logic

**File**: `src/auth/providers/base-provider.ts`

```typescript
protected handleClientRedirect(
  session: OAuthSession,
  code: string,
  state: string,
  res: Response
): boolean {
  if (session.clientRedirectUri) {
    const redirectUrl = new URL(session.clientRedirectUri);
    redirectUrl.searchParams.set('code', code);

    // ✅ Return client's original state, not server state
    const stateToReturn = session.clientState || state;
    redirectUrl.searchParams.set('state', stateToReturn);

    if (session.clientState) {
      logger.oauthDebug('Returning client original state', {
        provider: this.getProviderName(),
        clientStatePrefix: session.clientState.substring(0, 8)
      });
    }

    this.removeSession(state);
    this.setAntiCachingHeaders(res);
    res.redirect(redirectUrl.toString());
    return true;
  }

  return false;
}
```

#### 4. Provider Integration

**Files**:
- `src/auth/providers/google-provider.ts`
- `src/auth/providers/github-provider.ts`
- `src/auth/providers/microsoft-provider.ts`

```typescript
async handleAuthorizationRequest(req: Request, res: Response): Promise<void> {
  // Extract client parameters
  const {
    clientRedirectUri,
    clientCodeChallenge,
    clientCodeChallengeMethod,
    clientState  // ✅ Extract client state from query params
  } = this.extractClientParameters(req);

  // Setup PKCE
  const { state, codeVerifier, codeChallenge } = this.setupPKCE(clientCodeChallenge);

  // Create session with client state
  const session = this.createOAuthSession(
    state,
    codeVerifier,
    codeChallenge,
    clientRedirectUri,
    undefined,
    clientState  // ✅ Pass client state to session
  );

  this.storeSession(state, session);
  // ... continue OAuth flow
}
```

### Testing Strategy

#### Unit Tests

**File**: `test/unit/auth/providers/base-provider.test.ts`

Comprehensive test coverage (5 test cases):

1. **Client state storage and retrieval**
   - Verifies session stores both server and client state
   - Tests: `createOAuthSession()` with clientState parameter

2. **Client redirect with original state**
   - Verifies server returns client's state, not server state
   - Tests: `handleClientRedirect()` returns `session.clientState`

3. **Fallback to server state**
   - Verifies backward compatibility when no client state provided
   - Tests: `handleClientRedirect()` returns server state when `clientState` undefined

4. **No redirect without clientRedirectUri**
   - Verifies direct server usage (traditional OAuth)
   - Tests: `handleClientRedirect()` returns false without `clientRedirectUri`

5. **Session creation without client state**
   - Verifies optional client state field
   - Tests: `createOAuthSession()` without clientState parameter

**Test Execution:**
```bash
npm run test:unit         # All unit tests (436/436 passing)
npm run validate          # Full validation including tests
```

#### Manual Testing

**Verified with Claude Code:**
- User manually tested OAuth flow with Claude Code
- Dynamic Client Registration successful
- State preservation working correctly
- New client created: `client_id: d59444fe-5d6a-47c7-b27d-22b7d688986a`

## Consequences

### Benefits

**✅ Claude Code Integration**
- Seamless managed OAuth flow
- No manual token management required
- Production-ready agentic client support

**✅ MCP Inspector Compatibility**
- Full Dynamic Client Registration (RFC 7591) support
- Standard OAuth 2.1 compliance
- Developer-friendly testing workflow

**✅ Backward Compatibility**
- Existing direct server usage unchanged
- Traditional OAuth flows work as before
- No configuration changes required

**✅ Security Maintained**
- CSRF protection for both client and server
- State validation at each step
- No exposure of internal session state

**✅ Flexibility**
- Automatic detection of flow type (client-managed vs server-managed)
- Works with all OAuth providers (Google, GitHub, Microsoft, generic)
- Extensible for future OAuth clients

### Risks and Mitigations

**Risk: Increased Session Storage**
- **Impact**: Each session stores additional `clientState` field
- **Mitigation**: Optional field (undefined when not needed), minimal memory impact

**Risk: State Confusion**
- **Impact**: Developers might be confused by two state values
- **Mitigation**: Comprehensive documentation, clear logging, explicit field names

**Risk: Testing Complexity**
- **Impact**: More test scenarios to cover
- **Mitigation**: Added 5 comprehensive unit tests, validated manually

### Performance Impact

**Minimal overhead:**
- Single additional field in session object
- No additional network calls
- No computational complexity increase
- Single `if/else` check during redirect

### Documentation Updates

**Added comprehensive documentation:**
1. **oauth-setup.md**: Complete feature explanation with diagrams
2. **This ADR**: Architectural decision record
3. **Code comments**: Inline documentation in implementation
4. **CLAUDE.md**: Developer integration guide (pending)

## Alternatives Considered

### Alternative 1: Single State Value
**Description**: Use only server state, ignore client state
**Rejected**: Breaks CSRF protection for agentic clients

### Alternative 2: State Mapping Table
**Description**: Maintain separate mapping from server state to client state
**Rejected**: Unnecessary complexity, session already has all needed data

### Alternative 3: Proxy Mode
**Description**: Don't generate server state, pass through client state only
**Rejected**: Breaks server-managed OAuth flows (direct usage)

### Alternative 4: Two Separate Endpoints
**Description**: Different endpoints for client-managed vs server-managed OAuth
**Rejected**: Poor developer experience, unnecessary complexity

## References

- **RFC 6749**: OAuth 2.0 Authorization Framework (state parameter requirement)
- **RFC 9449**: OAuth 2.1 Authorization Framework (updated state requirements)
- **RFC 7591**: OAuth 2.0 Dynamic Client Registration Protocol
- **Issue Context**: User bug report with Claude Code "Invalid state parameter" error
- **Implementation**: PRs modifying base-provider.ts, types.ts, and all provider implementations
- **Testing**: `test/unit/auth/providers/base-provider.test.ts` (lines 282-402)

## Decision Record

**Date**: 2025-09-30

**Participants**: Jeff Dutton (CTO), Claude Code

**Status**: Accepted

**Implementation**: Completed and tested

**Validation**:
- ✅ 436/436 unit tests passing
- ✅ Manual testing successful with Claude Code
- ✅ Documentation complete
- ✅ Backward compatibility verified

**Review Date**: 2025-10-30 (30-day follow-up)